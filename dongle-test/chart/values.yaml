test: "pong"
testTemplate: "{{ $all := . }}\n{{ $servers := .Servers }}\n{{ $cfg := .Cfg }}\n{{ $IsIPV6Enabled := .IsIPV6Enabled }}\n{{ $healthzURI := .HealthzURI }}\n{{ $backends := .Backends }}\n{{ $proxyHeaders := .ProxySetHeaders }}\n{{ $addHeaders := .AddHeaders }}\n\n# Configuration checksum: {{ $all.Cfg.Checksum }}\n\n# setup custom paths that do not require root access\npid {{ .PID }};\n\n{{ if $cfg.UseGeoIP2 }}\nload_module /etc/nginx/modules/ngx_http_geoip2_module.so;\n{{ end }}\n\n{{ if $cfg.EnableBrotli }}\nload_module /etc/nginx/modules/ngx_http_brotli_filter_module.so;\nload_module /etc/nginx/modules/ngx_http_brotli_static_module.so;\n{{ end }}\n\n{{ if (shouldLoadInfluxDBModule $servers) }}\nload_module /etc/nginx/modules/ngx_http_influxdb_module.so;\n{{ end }}\n\n{{ if (shouldLoadAuthDigestModule $servers) }}\nload_module /etc/nginx/modules/ngx_http_auth_digest_module.so;\n{{ end }}\n\n{{ if (shouldLoadModSecurityModule $cfg $servers) }}\nload_module /etc/nginx/modules/ngx_http_modsecurity_module.so;\n{{ end }}\n\n{{ if (shouldLoadOpentracingModule $cfg $servers) }}\nload_module /etc/nginx/modules/ngx_http_opentracing_module.so;\n{{ end }}\n\ndaemon off;\n\nworker_processes {{ $cfg.WorkerProcesses }};\n{{ if gt (len $cfg.WorkerCPUAffinity) 0 }}\nworker_cpu_affinity {{ $cfg.WorkerCPUAffinity }};\n{{ end }}\n\nworker_rlimit_nofile {{ $cfg.MaxWorkerOpenFiles }};\n\n{{/* http://nginx.org/en/docs/ngx_core_module.html#worker_shutdown_timeout */}}\n{{/* avoid waiting too long during a reload */}}\nworker_shutdown_timeout {{ $cfg.WorkerShutdownTimeout }} ;\n\n{{ if not (empty $cfg.MainSnippet) }}\n{{ $cfg.MainSnippet }}\n{{ end }}\n\nevents {\n    multi_accept        {{ if $cfg.EnableMultiAccept }}on{{ else }}off{{ end }};\n    worker_connections  {{ $cfg.MaxWorkerConnections }};\n    use                 epoll;\n    {{ range $index , $v := $cfg.DebugConnections }}\n    debug_connection    {{ $v }};\n    {{ end }}\n}\n\nhttp {\n    lua_package_path \"/etc/nginx/lua/?.lua;;\";\n\n    {{ buildLuaSharedDictionaries $cfg $servers }}\n\n    init_by_lua_block {\n        collectgarbage(\"collect\")\n\n        -- init modules\n        local ok, res\n\n        ok, res = pcall(require, \"lua_ingress\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          lua_ingress = res\n          lua_ingress.set_config({{ configForLua $all }})\n        end\n\n        ok, res = pcall(require, \"configuration\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          configuration = res\n          configuration.prohibited_localhost_port = '{{ .StatusPort }}'\n        end\n\n        ok, res = pcall(require, \"balancer\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          balancer = res\n        end\n\n        {{ if $all.EnableMetrics }}\n        ok, res = pcall(require, \"monitor\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          monitor = res\n        end\n        {{ end }}\n\n        ok, res = pcall(require, \"certificate\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          certificate = res\n          certificate.is_ocsp_stapling_enabled = {{ $cfg.EnableOCSP }}\n        end\n\n        ok, res = pcall(require, \"plugins\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          plugins = res\n        end\n        -- load all plugins that'll be used here\n        plugins.init({ {{ range  $idx, $plugin := $cfg.Plugins }}{{ if $idx }},{{ end }}{{ $plugin | quote }}{{ end }} })\n    }\n\n    init_worker_by_lua_block {\n        lua_ingress.init_worker()\n        balancer.init_worker()\n        {{ if $all.EnableMetrics }}\n        monitor.init_worker({{ $all.MonitorMaxBatchSize }})\n        {{ end }}\n\n        plugins.run()\n    }\n\n    {{/* Enable the real_ip module only if we use either X-Forwarded headers or Proxy Protocol. */}}\n    {{/* we use the value of the real IP for the geo_ip module */}}\n    {{ if or (or $cfg.UseForwardedHeaders $cfg.UseProxyProtocol) $cfg.EnableRealIp }}\n    {{ if $cfg.UseProxyProtocol }}\n    real_ip_header      proxy_protocol;\n    {{ else }}\n    real_ip_header      {{ $cfg.ForwardedForHeader }};\n    {{ end }}\n\n    real_ip_recursive   on;\n    {{ range $trusted_ip := $cfg.ProxyRealIPCIDR }}\n    set_real_ip_from    {{ $trusted_ip }};\n    {{ end }}\n    {{ end }}\n\n    {{ if $all.Cfg.EnableModsecurity }}\n    modsecurity on;\n\n    {{ if (not (empty $all.Cfg.ModsecuritySnippet)) }}\n    modsecurity_rules '\n      {{ $all.Cfg.ModsecuritySnippet }}\n    ';\n    {{ else }}\n    modsecurity_rules_file /etc/nginx/modsecurity/modsecurity.conf;\n    {{ end }}\n\n    {{ if $all.Cfg.EnableOWASPCoreRules }}\n    modsecurity_rules_file /etc/nginx/owasp-modsecurity-crs/nginx-modsecurity.conf;\n    {{ end }}\n\n    {{ end }}\n\n    {{ if $cfg.UseGeoIP }}\n    {{/* databases used to determine the country depending on the client IP address */}}\n    {{/* http://nginx.org/en/docs/http/ngx_http_geoip_module.html */}}\n    {{/* this is require to calculate traffic for individual country using GeoIP in the status page */}}\n    geoip_country       /etc/nginx/geoip/GeoIP.dat;\n    geoip_city          /etc/nginx/geoip/GeoLiteCity.dat;\n    geoip_org           /etc/nginx/geoip/GeoIPASNum.dat;\n    geoip_proxy_recursive on;\n    {{ end }}\n\n    {{ if $cfg.UseGeoIP2 }}\n    # https://github.com/leev/ngx_http_geoip2_module#example-usage\n\n    {{ range $index, $file := $all.MaxmindEditionFiles }}\n    {{ if eq $file \"GeoLite2-Country.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoLite2-Country.mmdb {\n        $geoip2_country_code source=$remote_addr country iso_code;\n        $geoip2_country_name source=$remote_addr country names en;\n        $geoip2_continent_code source=$remote_addr continent code;\n        $geoip2_continent_name source=$remote_addr continent names en;\n    }\n    {{ end }}\n\n    {{ if eq $file \"GeoIP2-Country.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoIP2-Country.mmdb {\n        $geoip2_country_code source=$remote_addr country iso_code;\n        $geoip2_country_name source=$remote_addr country names en;\n        $geoip2_continent_code source=$remote_addr continent code;\n        $geoip2_continent_name source=$remote_addr continent names en;\n    }\n    {{ end }}\n\n    {{ if eq $file \"GeoLite2-City.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoLite2-City.mmdb {\n        $geoip2_city_country_code source=$remote_addr country iso_code;\n        $geoip2_city_country_name source=$remote_addr country names en;\n        $geoip2_city source=$remote_addr city names en;\n        $geoip2_postal_code source=$remote_addr postal code;\n        $geoip2_dma_code source=$remote_addr location metro_code;\n        $geoip2_latitude source=$remote_addr location latitude;\n        $geoip2_longitude source=$remote_addr location longitude;\n        $geoip2_time_zone source=$remote_addr location time_zone;\n        $geoip2_region_code source=$remote_addr subdivisions 0 iso_code;\n        $geoip2_region_name source=$remote_addr subdivisions 0 names en;\n        $geoip2_subregion_code source=$remote_addr subdivisions 1 iso_code;\n        $geoip2_subregion_name source=$remote_addr subdivisions 1 names en;\n    }\n    {{ end }}\n\n    {{ if eq $file \"GeoIP2-City.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoIP2-City.mmdb {\n        $geoip2_city_country_code source=$remote_addr country iso_code;\n        $geoip2_city_country_name source=$remote_addr country names en;\n        $geoip2_city source=$remote_addr city names en;\n        $geoip2_postal_code source=$remote_addr postal code;\n        $geoip2_dma_code source=$remote_addr location metro_code;\n        $geoip2_latitude source=$remote_addr location latitude;\n        $geoip2_longitude source=$remote_addr location longitude;\n        $geoip2_time_zone source=$remote_addr location time_zone;\n        $geoip2_region_code source=$remote_addr subdivisions 0 iso_code;\n        $geoip2_region_name source=$remote_addr subdivisions 0 names en;\n        $geoip2_subregion_code source=$remote_addr subdivisions 1 iso_code;\n        $geoip2_subregion_name source=$remote_addr subdivisions 1 names en;\n    }\n    {{ end }}\n\n    {{ if eq $file \"GeoLite2-ASN.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoLite2-ASN.mmdb {\n        $geoip2_asn source=$remote_addr autonomous_system_number;\n        $geoip2_org source=$remote_addr autonomous_system_organization;\n    }\n    {{ end }}\n\n    {{ if eq $file \"GeoIP2-ASN.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoIP2-ASN.mmdb {\n        $geoip2_asn source=$remote_addr autonomous_system_number;\n        $geoip2_org source=$remote_addr autonomous_system_organization;\n    }\n    {{ end }}\n\n    {{ if eq $file \"GeoIP2-ISP.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoIP2-ISP.mmdb {\n        $geoip2_isp source=$remote_addr isp;\n        $geoip2_isp_org source=$remote_addr organization;\n        $geoip2_asn source=$remote_addr default=0 autonomous_system_number;\n    }\n    {{ end }}\n\n    {{ if eq $file \"GeoIP2-Connection-Type.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoIP2-Connection-Type.mmdb {\n        $geoip2_connection_type connection_type;\n    }\n    {{ end }}\n\n    {{ if eq $file \"GeoIP2-Anonymous-IP.mmdb\" }}\n    geoip2 /etc/nginx/geoip/GeoIP2-Anonymous-IP.mmdb {\n        $geoip2_is_anon source=$remote_addr is_anonymous;\n        $geoip2_is_anonymous source=$remote_addr default=0 is_anonymous;\n        $geoip2_is_anonymous_vpn source=$remote_addr default=0 is_anonymous_vpn;\n        $geoip2_is_hosting_provider source=$remote_addr default=0 is_hosting_provider;\n        $geoip2_is_public_proxy source=$remote_addr default=0 is_public_proxy;\n        $geoip2_is_tor_exit_node source=$remote_addr default=0 is_tor_exit_node;\n    }\n    {{ end }}\n\n    {{ end }}\n\n    {{ end }}\n\n    aio                 threads;\n    aio_write           on;\n\n    tcp_nopush          on;\n    tcp_nodelay         on;\n\n    log_subrequest      on;\n\n    reset_timedout_connection on;\n\n    keepalive_timeout  {{ $cfg.KeepAlive }}s;\n    keepalive_requests {{ $cfg.KeepAliveRequests }};\n\n    client_body_temp_path           /tmp/nginx/client-body;\n    fastcgi_temp_path               /tmp/nginx/fastcgi-temp;\n    proxy_temp_path                 /tmp/nginx/proxy-temp;\n    ajp_temp_path                   /tmp/nginx/ajp-temp;\n\n    client_header_buffer_size       {{ $cfg.ClientHeaderBufferSize }};\n    client_header_timeout           {{ $cfg.ClientHeaderTimeout }}s;\n    large_client_header_buffers     {{ $cfg.LargeClientHeaderBuffers }};\n    client_body_buffer_size         {{ $cfg.ClientBodyBufferSize }};\n    client_body_timeout             {{ $cfg.ClientBodyTimeout }}s;\n\n    http2_max_field_size            {{ $cfg.HTTP2MaxFieldSize }};\n    http2_max_header_size           {{ $cfg.HTTP2MaxHeaderSize }};\n    http2_max_requests              {{ $cfg.HTTP2MaxRequests }};\n    http2_max_concurrent_streams    {{ $cfg.HTTP2MaxConcurrentStreams }};\n\n    types_hash_max_size             2048;\n    server_names_hash_max_size      {{ $cfg.ServerNameHashMaxSize }};\n    server_names_hash_bucket_size   {{ $cfg.ServerNameHashBucketSize }};\n    map_hash_bucket_size            {{ $cfg.MapHashBucketSize }};\n\n    proxy_headers_hash_max_size     {{ $cfg.ProxyHeadersHashMaxSize }};\n    proxy_headers_hash_bucket_size  {{ $cfg.ProxyHeadersHashBucketSize }};\n\n    variables_hash_bucket_size      {{ $cfg.VariablesHashBucketSize }};\n    variables_hash_max_size         {{ $cfg.VariablesHashMaxSize }};\n\n    underscores_in_headers          {{ if $cfg.EnableUnderscoresInHeaders }}on{{ else }}off{{ end }};\n    ignore_invalid_headers          {{ if $cfg.IgnoreInvalidHeaders }}on{{ else }}off{{ end }};\n\n    limit_req_status                {{ $cfg.LimitReqStatusCode }};\n    limit_conn_status               {{ $cfg.LimitConnStatusCode }};\n\n    {{ buildOpentracing $cfg $servers }}\n\n    include /etc/nginx/mime.types;\n    default_type {{ $cfg.DefaultType }};\n\n    {{ if $cfg.EnableBrotli }}\n    brotli on;\n    brotli_comp_level {{ $cfg.BrotliLevel }};\n    brotli_min_length {{ $cfg.BrotliMinLength }};\n    brotli_types {{ $cfg.BrotliTypes }};\n    {{ end }}\n\n    {{ if $cfg.UseGzip }}\n    gzip on;\n    gzip_comp_level {{ $cfg.GzipLevel }};\n    {{- if $cfg.GzipDisable }}\n    gzip_disable \"{{ $cfg.GzipDisable }}\";\n    {{- end }}\n    gzip_http_version 1.1;\n    gzip_min_length {{ $cfg.GzipMinLength}};\n    gzip_types {{ $cfg.GzipTypes }};\n    gzip_proxied any;\n    gzip_vary on;\n    {{ end }}\n\n    # Custom headers for response\n    {{ range $k, $v := $addHeaders }}\n    more_set_headers {{ printf \"%s: %s\" $k $v | quote }};\n    {{ end }}\n\n    server_tokens {{ if $cfg.ShowServerTokens }}on{{ else }}off{{ end }};\n    {{ if not $cfg.ShowServerTokens }}\n    more_clear_headers Server;\n    {{ end }}\n\n    # disable warnings\n    uninitialized_variable_warn off;\n\n    # Additional available variables:\n    # $namespace\n    # $ingress_name\n    # $service_name\n    # $service_port\n    log_format upstreaminfo {{ if $cfg.LogFormatEscapeNone }}escape=none {{ else if $cfg.LogFormatEscapeJSON }}escape=json {{ end }}'{{ $cfg.LogFormatUpstream }}';\n\n    {{/* map urls that should not appear in access.log */}}\n    {{/* http://nginx.org/en/docs/http/ngx_http_log_module.html#access_log */}}\n    map $request_uri $loggable {\n        {{ range $reqUri := $cfg.SkipAccessLogURLs }}\n        {{ $reqUri }} 0;{{ end }}\n        default 1;\n    }\n\n    {{ if or $cfg.DisableAccessLog $cfg.DisableHTTPAccessLog }}\n    access_log off;\n    {{ else }}\n    {{ if $cfg.EnableSyslog }}\n    access_log syslog:server={{ $cfg.SyslogHost }}:{{ $cfg.SyslogPort }} upstreaminfo if=$loggable;\n    {{ else }}\n    access_log {{ or $cfg.HttpAccessLogPath $cfg.AccessLogPath }} upstreaminfo {{ $cfg.AccessLogParams }} if=$loggable;\n    {{ end }}\n    {{ end }}\n\n    {{ if $cfg.EnableSyslog }}\n    error_log syslog:server={{ $cfg.SyslogHost }}:{{ $cfg.SyslogPort }} {{ $cfg.ErrorLogLevel }};\n    {{ else }}\n    error_log  {{ $cfg.ErrorLogPath }} {{ $cfg.ErrorLogLevel }};\n    {{ end }}\n\n    {{ buildResolvers $cfg.Resolver $cfg.DisableIpv6DNS }}\n\n    # See https://www.nginx.com/blog/websocket-nginx\n    map $http_upgrade $connection_upgrade {\n        default          upgrade;\n        {{ if (gt $cfg.UpstreamKeepaliveConnections 0) }}\n        # See http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive\n        ''               '';\n        {{ else }}\n        ''               close;\n        {{ end }}\n    }\n\n    # Reverse proxies can detect if a client provides a X-Request-ID header, and pass it on to the backend server.\n    # If no such header is provided, it can provide a random value.\n    map $http_x_request_id $req_id {\n        default   $http_x_request_id;\n        {{ if $cfg.GenerateRequestID }}\n        \"\"        $request_id;\n        {{ end }}\n    }\n\n    {{ if and $cfg.UseForwardedHeaders $cfg.ComputeFullForwardedFor }}\n    # We can't use $proxy_add_x_forwarded_for because the realip module\n    # replaces the remote_addr too soon\n    map $http_x_forwarded_for $full_x_forwarded_for {\n        {{ if $all.Cfg.UseProxyProtocol }}\n        default          \"$http_x_forwarded_for, $proxy_protocol_addr\";\n        ''               \"$proxy_protocol_addr\";\n        {{ else }}\n        default          \"$http_x_forwarded_for, $realip_remote_addr\";\n        ''               \"$realip_remote_addr\";\n        {{ end}}\n    }\n\n    {{ end }}\n\n    # Create a variable that contains the literal $ character.\n    # This works because the geo module will not resolve variables.\n    geo $literal_dollar {\n        default \"$\";\n    }\n\n    server_name_in_redirect off;\n    port_in_redirect        off;\n\n    ssl_protocols {{ $cfg.SSLProtocols }};\n\n    ssl_early_data {{ if $cfg.SSLEarlyData }}on{{ else }}off{{ end }};\n\n    # turn on session caching to drastically improve performance\n    {{ if $cfg.SSLSessionCache }}\n    ssl_session_cache shared:SSL:{{ $cfg.SSLSessionCacheSize }};\n    ssl_session_timeout {{ $cfg.SSLSessionTimeout }};\n    {{ end }}\n\n    # allow configuring ssl session tickets\n    ssl_session_tickets {{ if $cfg.SSLSessionTickets }}on{{ else }}off{{ end }};\n\n    {{ if not (empty $cfg.SSLSessionTicketKey ) }}\n    ssl_session_ticket_key /etc/nginx/tickets.key;\n    {{ end }}\n\n    # slightly reduce the time-to-first-byte\n    ssl_buffer_size {{ $cfg.SSLBufferSize }};\n\n    {{ if not (empty $cfg.SSLCiphers) }}\n    # allow configuring custom ssl ciphers\n    ssl_ciphers '{{ $cfg.SSLCiphers }}';\n    ssl_prefer_server_ciphers on;\n    {{ end }}\n\n    {{ if not (empty $cfg.SSLDHParam) }}\n    # allow custom DH file http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_dhparam\n    ssl_dhparam {{ $cfg.SSLDHParam }};\n    {{ end }}\n\n    ssl_ecdh_curve {{ $cfg.SSLECDHCurve }};\n\n    # PEM sha: {{ $cfg.DefaultSSLCertificate.PemSHA }}\n    ssl_certificate     {{ $cfg.DefaultSSLCertificate.PemFileName }};\n    ssl_certificate_key {{ $cfg.DefaultSSLCertificate.PemFileName }};\n\n    {{ if gt (len $cfg.CustomHTTPErrors) 0 }}\n    proxy_intercept_errors on;\n    {{ end }}\n\n    {{ range $errCode := $cfg.CustomHTTPErrors }}\n    error_page {{ $errCode }} = @custom_upstream-default-backend_{{ $errCode }};{{ end }}\n\n    proxy_ssl_session_reuse on;\n\n    {{ if $cfg.AllowBackendServerHeader }}\n    proxy_pass_header Server;\n    {{ end }}\n\n    {{ range $header := $cfg.HideHeaders }}proxy_hide_header {{ $header }};\n    {{ end }}\n\n    {{ if not (empty $cfg.HTTPSnippet) }}\n    # Custom code snippet configured in the configuration configmap\n    {{ $cfg.HTTPSnippet }}\n    {{ end }}\n\n    upstream upstream_balancer {\n        ### Attention!!!\n        #\n        # We no longer create \"upstream\" section for every backend.\n        # Backends are handled dynamically using Lua. If you would like to debug\n        # and see what backends ingress-nginx has in its memory you can\n        # install our kubectl plugin https://kubernetes.github.io/ingress-nginx/kubectl-plugin.\n        # Once you have the plugin you can use \"kubectl ingress-nginx backends\" command to\n        # inspect current backends.\n        #\n        ###\n\n        server 0.0.0.1; # placeholder\n\n        balancer_by_lua_block {\n          balancer.balance()\n        }\n\n        {{ if (gt $cfg.UpstreamKeepaliveConnections 0) }}\n        keepalive {{ $cfg.UpstreamKeepaliveConnections }};\n        keepalive_time {{ $cfg.UpstreamKeepaliveTime }};\n        keepalive_timeout  {{ $cfg.UpstreamKeepaliveTimeout }}s;\n        keepalive_requests {{ $cfg.UpstreamKeepaliveRequests }};\n        {{ end }}\n    }\n\n    {{ range $rl := (filterRateLimits $servers ) }}\n    # Ratelimit {{ $rl.Name }}\n    geo $remote_addr $whitelist_{{ $rl.ID }} {\n        default 0;\n        {{ range $ip := $rl.Whitelist }}\n        {{ $ip }} 1;{{ end }}\n    }\n\n    # Ratelimit {{ $rl.Name }}\n    map $whitelist_{{ $rl.ID }} $limit_{{ $rl.ID }} {\n        0 {{ $cfg.LimitConnZoneVariable }};\n        1 \"\";\n    }\n    {{ end }}\n\n    {{/* build all the required rate limit zones. Each annotation requires a dedicated zone */}}\n    {{/* 1MB -\u003e 16 thousand 64-byte states or about 8 thousand 128-byte states */}}\n    {{ range $zone := (buildRateLimitZones $servers) }}\n    {{ $zone }}\n    {{ end }}\n\n    # Cache for internal auth checks\n    proxy_cache_path /tmp/nginx/nginx-cache-auth levels=1:2 keys_zone=auth_cache:10m max_size=128m inactive=30m use_temp_path=off;\n\n    # Global filters\n    {{ range $ip := $cfg.BlockCIDRs }}deny {{ trimSpace $ip }};\n    {{ end }}\n\n    {{ if gt (len $cfg.BlockUserAgents) 0 }}\n    map $http_user_agent $block_ua {\n        default 0;\n\n        {{ range $ua := $cfg.BlockUserAgents }}{{ trimSpace $ua }} 1;\n        {{ end }}\n    }\n    {{ end }}\n\n    {{ if gt (len $cfg.BlockReferers) 0 }}\n    map $http_referer $block_ref {\n        default 0;\n\n        {{ range $ref := $cfg.BlockReferers }}{{ trimSpace $ref }} 1;\n        {{ end }}\n    }\n    {{ end }}\n\n    {{/* Build server redirects (from/to www) */}}\n    {{ range $redirect := .RedirectServers }}\n    ## start server {{ $redirect.From }}\n    server {\n        server_name {{ $redirect.From }};\n\n        {{ buildHTTPListener  $all $redirect.From }}\n        {{ buildHTTPSListener $all $redirect.From }}\n\n        ssl_certificate_by_lua_block {\n            certificate.call()\n        }\n\n        {{ if gt (len $cfg.BlockUserAgents) 0 }}\n        if ($block_ua) {\n           return 403;\n        }\n        {{ end }}\n        {{ if gt (len $cfg.BlockReferers) 0 }}\n        if ($block_ref) {\n           return 403;\n        }\n        {{ end }}\n\n        set_by_lua_block $redirect_to {\n            local request_uri = ngx.var.request_uri\n            if string.sub(request_uri, -1) == \"/\" then\n                request_uri = string.sub(request_uri, 1, -2)\n            end\n\n            {{ if $cfg.UseForwardedHeaders }}\n            local redirectScheme\n            if not ngx.var.http_x_forwarded_proto then\n                redirectScheme = ngx.var.scheme\n            else\n                redirectScheme = ngx.var.http_x_forwarded_proto\n            end\n            {{ else }}\n            local redirectScheme = ngx.var.scheme\n            {{ end }}\n\n            {{ if ne $all.ListenPorts.HTTPS 443 }}\n            {{ $redirect_port := (printf \":%v\" $all.ListenPorts.HTTPS) }}\n            return string.format(\"%s://%s%s%s\", redirectScheme, \"{{ $redirect.To }}\", \"{{ $redirect_port }}\", request_uri)\n            {{ else }}\n            return string.format(\"%s://%s%s\", redirectScheme, \"{{ $redirect.To }}\", request_uri)\n            {{ end }}\n        }\n\n        return {{ $all.Cfg.HTTPRedirectCode }} $redirect_to;\n    }\n    ## end server {{ $redirect.From }}\n    {{ end }}\n\n    {{ range $server := $servers }}\n    {{ range $location := $server.Locations }}\n    {{ $applyGlobalAuth := shouldApplyGlobalAuth $location $all.Cfg.GlobalExternalAuth.URL }}\n    {{ $applyAuthUpstream := shouldApplyAuthUpstream $location $all.Cfg }}\n    {{ if and (eq $applyAuthUpstream true) (eq $applyGlobalAuth false) }}\n    ## start auth upstream {{ $server.Hostname }}{{ $location.Path }}\n    upstream {{ buildAuthUpstreamName $location $server.Hostname }} {\n        {{- $externalAuth := $location.ExternalAuth }}\n        server {{ extractHostPort $externalAuth.URL }};\n\n        keepalive {{ $externalAuth.KeepaliveConnections }};\n        keepalive_requests {{ $externalAuth.KeepaliveRequests }};\n        keepalive_timeout {{ $externalAuth.KeepaliveTimeout }}s;\n    }\n    ## end auth upstream {{ $server.Hostname }}{{ $location.Path }}\n    {{ end }}\n    {{ end }}\n    {{ end }}\n\n    {{ range $server := $servers }}\n    ## start server {{ $server.Hostname }}\n    server {\n        server_name {{ buildServerName $server.Hostname }} {{range $server.Aliases }}{{ . }} {{ end }};\n\n        {{ if gt (len $cfg.BlockUserAgents) 0 }}\n        if ($block_ua) {\n           return 403;\n        }\n        {{ end }}\n        {{ if gt (len $cfg.BlockReferers) 0 }}\n        if ($block_ref) {\n           return 403;\n        }\n        {{ end }}\n\n        {{ template \"SERVER\" serverConfig $all $server }}\n\n        {{ if not (empty $cfg.ServerSnippet) }}\n        # Custom code snippet configured in the configuration configmap\n        {{ $cfg.ServerSnippet }}\n        {{ end }}\n\n        {{ template \"CUSTOM_ERRORS\" (buildCustomErrorDeps \"upstream-default-backend\" $cfg.CustomHTTPErrors $all.EnableMetrics $cfg.EnableModsecurity) }}\n    }\n    ## end server {{ $server.Hostname }}\n\n    {{ end }}\n\n    # backend for when default-backend-service is not configured or it does not have endpoints\n    server {\n        listen {{ $all.ListenPorts.Default }} default_server {{ if $all.Cfg.ReusePort }}reuseport{{ end }} backlog={{ $all.BacklogSize }};\n        {{ if $IsIPV6Enabled }}listen [::]:{{ $all.ListenPorts.Default }} default_server {{ if $all.Cfg.ReusePort }}reuseport{{ end }} backlog={{ $all.BacklogSize }};{{ end }}\n        set $proxy_upstream_name \"internal\";\n\n        access_log off;\n\n        location / {\n          return 404;\n        }\n    }\n\n    # default server, used for NGINX healthcheck and access to nginx stats\n    server {\n        listen 127.0.0.1:{{ .StatusPort }};\n        set $proxy_upstream_name \"internal\";\n\n        keepalive_timeout 0;\n        gzip off;\n\n        access_log off;\n\n        {{ if $cfg.EnableOpentracing }}\n        opentracing off;\n        {{ end }}\n\n        location {{ $healthzURI }} {\n            return 200;\n        }\n\n        location /is-dynamic-lb-initialized {\n            content_by_lua_block {\n                local configuration = require(\"configuration\")\n                local backend_data = configuration.get_backends_data()\n                if not backend_data then\n                    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n                    return\n                end\n\n                ngx.say(\"OK\")\n                ngx.exit(ngx.HTTP_OK)\n            }\n        }\n\n        location {{ .StatusPath }} {\n            stub_status on;\n        }\n\n        location /configuration {\n            client_max_body_size                    {{ luaConfigurationRequestBodySize $cfg }};\n            client_body_buffer_size                 {{ luaConfigurationRequestBodySize $cfg }};\n            proxy_buffering                         off;\n\n            content_by_lua_block {\n              configuration.call()\n            }\n        }\n\n        location / {\n            content_by_lua_block {\n                ngx.exit(ngx.HTTP_NOT_FOUND)\n            }\n        }\n    }\n}\n\nstream {\n    lua_package_path \"/etc/nginx/lua/?.lua;/etc/nginx/lua/vendor/?.lua;;\";\n\n    lua_shared_dict tcp_udp_configuration_data 5M;\n\n    {{ buildResolvers $cfg.Resolver $cfg.DisableIpv6DNS }}\n\n    init_by_lua_block {\n        collectgarbage(\"collect\")\n\n        -- init modules\n        local ok, res\n\n        ok, res = pcall(require, \"configuration\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          configuration = res\n        end\n\n        ok, res = pcall(require, \"tcp_udp_configuration\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          tcp_udp_configuration = res\n          tcp_udp_configuration.prohibited_localhost_port = '{{ .StatusPort }}'\n\n        end\n\n        ok, res = pcall(require, \"tcp_udp_balancer\")\n        if not ok then\n          error(\"require failed: \" .. tostring(res))\n        else\n          tcp_udp_balancer = res\n        end\n    }\n\n    init_worker_by_lua_block {\n        tcp_udp_balancer.init_worker()\n    }\n\n    lua_add_variable $proxy_upstream_name;\n\n    log_format log_stream '{{ $cfg.LogFormatStream }}';\n\n    {{ if or $cfg.DisableAccessLog $cfg.DisableStreamAccessLog }}\n    access_log off;\n    {{ else }}\n    access_log {{ or $cfg.StreamAccessLogPath $cfg.AccessLogPath }} log_stream {{ $cfg.AccessLogParams }};\n    {{ end }}\n\n\n    error_log  {{ $cfg.ErrorLogPath }} {{ $cfg.ErrorLogLevel }};\n    {{ if $cfg.EnableRealIp }}\n    {{ range $trusted_ip := $cfg.ProxyRealIPCIDR }}\n    set_real_ip_from    {{ $trusted_ip }};\n    {{ end }}\n    {{ end }}\n\n    upstream upstream_balancer {\n        server 0.0.0.1:1234; # placeholder\n\n        balancer_by_lua_block {\n          tcp_udp_balancer.balance()\n        }\n    }\n\n    server {\n        listen 127.0.0.1:{{ .StreamPort }};\n\n        access_log off;\n\n        content_by_lua_block {\n          tcp_udp_configuration.call()\n        }\n    }\n\n    # TCP services\n    {{ range $tcpServer := .TCPBackends }}\n    server {\n        preread_by_lua_block {\n            ngx.var.proxy_upstream_name=\"tcp-{{ $tcpServer.Backend.Namespace }}-{{ $tcpServer.Backend.Name }}-{{ $tcpServer.Backend.Port }}\";\n        }\n\n        {{ range $address := $all.Cfg.BindAddressIpv4 }}\n        listen                  {{ $address }}:{{ $tcpServer.Port }}{{ if $tcpServer.Backend.ProxyProtocol.Decode }} proxy_protocol{{ end }};\n        {{ else }}\n        listen                  {{ $tcpServer.Port }}{{ if $tcpServer.Backend.ProxyProtocol.Decode }} proxy_protocol{{ end }};\n        {{ end }}\n        {{ if $IsIPV6Enabled }}\n        {{ range $address := $all.Cfg.BindAddressIpv6 }}\n        listen                  {{ $address }}:{{ $tcpServer.Port }}{{ if $tcpServer.Backend.ProxyProtocol.Decode }} proxy_protocol{{ end }};\n        {{ else }}\n        listen                  [::]:{{ $tcpServer.Port }}{{ if $tcpServer.Backend.ProxyProtocol.Decode }} proxy_protocol{{ end }};\n        {{ end }}\n        {{ end }}\n        proxy_timeout           {{ $cfg.ProxyStreamTimeout }};\n        proxy_next_upstream     {{ if $cfg.ProxyStreamNextUpstream }}on{{ else }}off{{ end }};\n        proxy_next_upstream_timeout {{ $cfg.ProxyStreamNextUpstreamTimeout }};\n        proxy_next_upstream_tries   {{ $cfg.ProxyStreamNextUpstreamTries }};\n\n        proxy_pass              upstream_balancer;\n        {{ if $tcpServer.Backend.ProxyProtocol.Encode }}\n        proxy_protocol          on;\n        {{ end }}\n    }\n    {{ end }}\n\n    # UDP services\n    {{ range $udpServer := .UDPBackends }}\n    server {\n        preread_by_lua_block {\n            ngx.var.proxy_upstream_name=\"udp-{{ $udpServer.Backend.Namespace }}-{{ $udpServer.Backend.Name }}-{{ $udpServer.Backend.Port }}\";\n        }\n\n        {{ range $address := $all.Cfg.BindAddressIpv4 }}\n        listen                  {{ $address }}:{{ $udpServer.Port }} udp;\n        {{ else }}\n        listen                  {{ $udpServer.Port }} udp;\n        {{ end }}\n        {{ if $IsIPV6Enabled }}\n        {{ range $address := $all.Cfg.BindAddressIpv6 }}\n        listen                  {{ $address }}:{{ $udpServer.Port }} udp;\n        {{ else }}\n        listen                  [::]:{{ $udpServer.Port }} udp;\n        {{ end }}\n        {{ end }}\n        proxy_responses         {{ $cfg.ProxyStreamResponses }};\n        proxy_timeout           {{ $cfg.ProxyStreamTimeout }};\n        proxy_next_upstream     {{ if $cfg.ProxyStreamNextUpstream }}on{{ else }}off{{ end }};\n        proxy_next_upstream_timeout {{ $cfg.ProxyStreamNextUpstreamTimeout }};\n        proxy_next_upstream_tries   {{ $cfg.ProxyStreamNextUpstreamTries }};\n        proxy_pass              upstream_balancer;\n    }\n    {{ end }}\n\n    # Stream Snippets\n    {{ range $snippet := .StreamSnippets }}\n    {{ $snippet }}\n    {{ end }}\n}\n\n{{/* definition of templates to avoid repetitions */}}\n{{ define \"CUSTOM_ERRORS\" }}\n        {{ $enableMetrics := .EnableMetrics }}\n        {{ $modsecurityEnabled := .ModsecurityEnabled }}\n        {{ $upstreamName := .UpstreamName }}\n        {{ range $errCode := .ErrorCodes }}\n        location @custom_{{ $upstreamName }}_{{ $errCode }} {\n            internal;\n\n            # Ensure that modsecurity will not run on custom error pages or they might be blocked\n            {{ if $modsecurityEnabled }}\n            modsecurity off;\n            {{ end }}\n\n            proxy_intercept_errors off;\n\n            proxy_set_header       X-Code             {{ $errCode }};\n            proxy_set_header       X-Format           $http_accept;\n            proxy_set_header       X-Original-URI     $request_uri;\n            proxy_set_header       X-Namespace        $namespace;\n            proxy_set_header       X-Ingress-Name     $ingress_name;\n            proxy_set_header       X-Service-Name     $service_name;\n            proxy_set_header       X-Service-Port     $service_port;\n            proxy_set_header       X-Request-ID       $req_id;\n            proxy_set_header       X-Forwarded-For    $remote_addr;\n            proxy_set_header       Host               $best_http_host;\n\n            set $proxy_upstream_name {{ $upstreamName | quote }};\n\n            rewrite                (.*) / break;\n\n            proxy_pass            http://upstream_balancer;\n            log_by_lua_block {\n                {{ if $enableMetrics }}\n                monitor.call()\n                {{ end }}\n            }\n        }\n        {{ end }}\n{{ end }}\n\n{{/* CORS support from https://michielkalkman.com/snippets/nginx-cors-open-configuration.html */}}\n{{ define \"CORS\" }}\n     {{ $cors := .CorsConfig }}\n     # Cors Preflight methods needs additional options and different Return Code\n     {{ if $cors.CorsAllowOrigin }}\n        {{ buildCorsOriginRegex $cors.CorsAllowOrigin }}\n     {{ end }}\n     if ($request_method = 'OPTIONS') {\n        set $cors ${cors}options;\n     }\n\n     if ($cors = \"true\") {\n        more_set_headers 'Access-Control-Allow-Origin: $http_origin';\n        {{ if $cors.CorsAllowCredentials }} more_set_headers 'Access-Control-Allow-Credentials: {{ $cors.CorsAllowCredentials }}'; {{ end }}\n        more_set_headers 'Access-Control-Allow-Methods: {{ $cors.CorsAllowMethods }}';\n        {{ if not (empty $cors.CorsAllowHeaders) }}\n        more_set_headers 'Access-Control-Allow-Headers: Authorization,{{ $cors.CorsAllowHeaders }}';\n        {{ else }}\n        more_set_headers 'Access-Control-Allow-Headers: Authorization';\n        {{ end }}\n        {{ if not (empty $cors.CorsExposeHeaders) }} more_set_headers 'Access-Control-Expose-Headers: {{ $cors.CorsExposeHeaders }}'; {{ end }}\n        more_set_headers 'Access-Control-Max-Age: {{ $cors.CorsMaxAge }}';\n     }\n\n     if ($cors = \"trueoptions\") {\n        more_set_headers 'Access-Control-Allow-Origin: $http_origin';\n        {{ if $cors.CorsAllowCredentials }} more_set_headers 'Access-Control-Allow-Credentials: {{ $cors.CorsAllowCredentials }}'; {{ end }}\n        more_set_headers 'Access-Control-Allow-Methods: {{ $cors.CorsAllowMethods }}';\n        {{ if not (empty $cors.CorsAllowHeaders) }}\n        more_set_headers 'Access-Control-Allow-Headers: Authorization,{{ $cors.CorsAllowHeaders }}';\n        {{ else }}\n        more_set_headers 'Access-Control-Allow-Headers: Authorization';\n        {{ end }}\n        {{ if not (empty $cors.CorsExposeHeaders) }} more_set_headers 'Access-Control-Expose-Headers: {{ $cors.CorsExposeHeaders }}'; {{ end }}\n        more_set_headers 'Access-Control-Max-Age: {{ $cors.CorsMaxAge }}';\n        more_set_headers 'Content-Type: text/plain charset=UTF-8';\n        more_set_headers 'Content-Length: 0';\n        return 204;\n     }\n{{ end }}\n\n{{/* definition of server-template to avoid repetitions with server-alias */}}\n{{ define \"SERVER\" }}\n        {{ $all := .First }}\n        {{ $server := .Second }}\n\n        {{ buildHTTPListener  $all $server.Hostname }}\n        {{ buildHTTPSListener $all $server.Hostname }}\n\n        set $proxy_upstream_name \"-\";\n\n        {{ if not ( empty $server.CertificateAuth.MatchCN ) }}\n        {{ if gt (len $server.CertificateAuth.MatchCN) 0 }}\n        if ( $ssl_client_s_dn !~ {{ $server.CertificateAuth.MatchCN }} ) {\n            return 403 \"client certificate unauthorized\";\n        }\n        {{ end }}\n        {{ end }}\n\n        {{ if eq $server.Hostname \"_\" }}\n        ssl_reject_handshake {{ if $all.Cfg.SSLRejectHandshake }}on{{ else }}off{{ end }};\n        {{ end }}\n\n        ssl_certificate_by_lua_block {\n            certificate.call()\n        }\n\n        {{ if not (empty $server.AuthTLSError) }}\n        # {{ $server.AuthTLSError }}\n        return 403;\n        {{ else }}\n\n        {{ if not (empty $server.CertificateAuth.CAFileName) }}\n        # PEM sha: {{ $server.CertificateAuth.CASHA }}\n        ssl_client_certificate                  {{ $server.CertificateAuth.CAFileName }};\n        ssl_verify_client                       {{ $server.CertificateAuth.VerifyClient }};\n        ssl_verify_depth                        {{ $server.CertificateAuth.ValidationDepth }};\n\n        {{ if not (empty $server.CertificateAuth.CRLFileName) }}\n        # PEM sha: {{ $server.CertificateAuth.CRLSHA }}\n        ssl_crl                                 {{ $server.CertificateAuth.CRLFileName }};\n        {{ end }}\n\n        {{ if not (empty $server.CertificateAuth.ErrorPage)}}\n        error_page 495 496 = {{ $server.CertificateAuth.ErrorPage }};\n        {{ end }}\n        {{ end }}\n\n        {{ if not (empty $server.ProxySSL.CAFileName) }}\n        # PEM sha: {{ $server.ProxySSL.CASHA }}\n        proxy_ssl_trusted_certificate           {{ $server.ProxySSL.CAFileName }};\n        proxy_ssl_ciphers                       {{ $server.ProxySSL.Ciphers }};\n        proxy_ssl_protocols                     {{ $server.ProxySSL.Protocols }};\n        proxy_ssl_verify                        {{ $server.ProxySSL.Verify }};\n        proxy_ssl_verify_depth                  {{ $server.ProxySSL.VerifyDepth }};\n        {{ if not (empty $server.ProxySSL.ProxySSLName) }}\n        proxy_ssl_name                          {{ $server.ProxySSL.ProxySSLName }};\n        proxy_ssl_server_name                   {{ $server.ProxySSL.ProxySSLServerName }};\n        {{ end }}\n        {{ end }}\n\n        {{ if not (empty $server.ProxySSL.PemFileName) }}\n        proxy_ssl_certificate                   {{ $server.ProxySSL.PemFileName }};\n        proxy_ssl_certificate_key               {{ $server.ProxySSL.PemFileName }};\n        {{ end }}\n\n        {{ if not (empty $server.SSLCiphers) }}\n        ssl_ciphers                             {{ $server.SSLCiphers }};\n        {{ end }}\n\n        {{ if not (empty $server.SSLPreferServerCiphers) }}\n        ssl_prefer_server_ciphers               {{ $server.SSLPreferServerCiphers }};\n        {{ end }}\n\n        {{ if not (empty $server.ServerSnippet) }}\n        # Custom code snippet configured for host {{ $server.Hostname }}\n        {{ $server.ServerSnippet }}\n        {{ end }}\n\n        {{ range $errorLocation := (buildCustomErrorLocationsPerServer $server) }}\n        {{ template \"CUSTOM_ERRORS\" (buildCustomErrorDeps $errorLocation.UpstreamName $errorLocation.Codes $all.EnableMetrics $all.Cfg.EnableModsecurity) }}\n        {{ end }}\n\n        {{ buildMirrorLocations $server.Locations }}\n\n        {{ $enforceRegex := enforceRegexModifier $server.Locations }}\n        {{ range $location := $server.Locations }}\n        {{ $path := buildLocation $location $enforceRegex }}\n        {{ $proxySetHeader := proxySetHeader $location }}\n        {{ $authPath := buildAuthLocation $location $all.Cfg.GlobalExternalAuth.URL }}\n        {{ $applyGlobalAuth := shouldApplyGlobalAuth $location $all.Cfg.GlobalExternalAuth.URL }}\n        {{ $applyAuthUpstream := shouldApplyAuthUpstream $location $all.Cfg }}\n\n        {{ $externalAuth := $location.ExternalAuth }}\n        {{ if eq $applyGlobalAuth true }}\n        {{ $externalAuth = $all.Cfg.GlobalExternalAuth }}\n        {{ end }}\n\n        {{ if not (empty $location.Rewrite.AppRoot) }}\n        if ($uri = /) {\n            return 302 $scheme://$http_host{{ $location.Rewrite.AppRoot }};\n        }\n        {{ end }}\n\n        {{ if $authPath }}\n        location = {{ $authPath }} {\n            internal;\n\n            {{ if (or $all.Cfg.EnableOpentracing $location.Opentracing.Enabled) }}\n            opentracing on;\n            opentracing_propagate_context;\n            {{ end }}\n\n            access_log off;\n\n            # Ensure that modsecurity will not run on an internal location as this is not accessible from outside\n            {{ if $all.Cfg.EnableModsecurity }}\n            modsecurity off;\n            {{ end }}\n\n            {{ if $externalAuth.AuthCacheKey }}\n            set $tmp_cache_key '{{ $server.Hostname }}{{ $authPath }}{{ $externalAuth.AuthCacheKey }}';\n            set $cache_key '';\n\n            rewrite_by_lua_block {\n                ngx.var.cache_key = ngx.encode_base64(ngx.sha1_bin(ngx.var.tmp_cache_key))\n            }\n\n            proxy_cache auth_cache;\n\n            {{- range $dur := $externalAuth.AuthCacheDuration }}\n            proxy_cache_valid {{ $dur }};\n            {{- end }}\n\n            proxy_cache_key \"$cache_key\";\n            {{ end }}\n\n            # ngx_auth_request module overrides variables in the parent request,\n            # therefore we have to explicitly set this variable again so that when the parent request\n            # resumes it has the correct value set for this variable so that Lua can pick backend correctly\n            set $proxy_upstream_name {{ buildUpstreamName $location | quote }};\n\n            proxy_pass_request_body     off;\n            proxy_set_header            Content-Length          \"\";\n            proxy_set_header            X-Forwarded-Proto       \"\";\n            proxy_set_header            X-Request-ID            $req_id;\n\n            {{ if $externalAuth.Method }}\n            proxy_method                {{ $externalAuth.Method }};\n            proxy_set_header            X-Original-URI          $request_uri;\n            proxy_set_header            X-Scheme                $pass_access_scheme;\n            {{ end }}\n\n            proxy_set_header            Host                    {{ $externalAuth.Host }};\n            proxy_set_header            X-Original-URL          $scheme://$http_host$request_uri;\n            proxy_set_header            X-Original-Method       $request_method;\n            proxy_set_header            X-Sent-From             \"nginx-ingress-controller\";\n            proxy_set_header            X-Real-IP               $remote_addr;\n            {{ if and $all.Cfg.UseForwardedHeaders $all.Cfg.ComputeFullForwardedFor }}\n            proxy_set_header            X-Forwarded-For        $full_x_forwarded_for;\n            {{ else }}\n            proxy_set_header            X-Forwarded-For        $remote_addr;\n            {{ end }}\n\n            {{ if $externalAuth.RequestRedirect }}\n            proxy_set_header            X-Auth-Request-Redirect {{ $externalAuth.RequestRedirect }};\n            {{ else }}\n            proxy_set_header            X-Auth-Request-Redirect $request_uri;\n            {{ end }}\n\n            {{ if $externalAuth.AuthCacheKey }}\n            proxy_buffering                         \"on\";\n            {{ else }}\n            proxy_buffering                         {{ $location.Proxy.ProxyBuffering }};\n            {{ end }}\n            proxy_buffer_size                       {{ $location.Proxy.BufferSize }};\n            proxy_buffers                           {{ $location.Proxy.BuffersNumber }} {{ $location.Proxy.BufferSize }};\n            proxy_request_buffering                 {{ $location.Proxy.RequestBuffering }};\n\n            proxy_ssl_server_name       on;\n            proxy_pass_request_headers  on;\n            {{ if isValidByteSize $location.Proxy.BodySize true }}\n            client_max_body_size        {{ $location.Proxy.BodySize }};\n            {{ end }}\n            {{ if isValidByteSize $location.ClientBodyBufferSize false }}\n            client_body_buffer_size     {{ $location.ClientBodyBufferSize }};\n            {{ end }}\n\n            # Pass the extracted client certificate to the auth provider\n            {{ if not (empty $server.CertificateAuth.CAFileName) }}\n            {{ if $server.CertificateAuth.PassCertToUpstream }}\n            proxy_set_header ssl-client-cert        $ssl_client_escaped_cert;\n            {{ end }}\n            proxy_set_header ssl-client-verify      $ssl_client_verify;\n            proxy_set_header ssl-client-subject-dn  $ssl_client_s_dn;\n            proxy_set_header ssl-client-issuer-dn   $ssl_client_i_dn;\n            {{ end }}\n\n            {{- range $line := buildAuthProxySetHeaders $externalAuth.ProxySetHeaders}}\n            {{ $line }}\n            {{- end }}\n\n            {{ if not (empty $externalAuth.AuthSnippet) }}\n            {{ $externalAuth.AuthSnippet }}\n            {{ end }}\n\n            {{ if and (eq $applyAuthUpstream true) (eq $applyGlobalAuth false) }}\n            {{ $authUpstreamName := buildAuthUpstreamName $location $server.Hostname }}\n            # The target is an upstream with HTTP keepalive, that is why the\n            # Connection header is cleared and the HTTP version is set to 1.1 as\n            # the Nginx documentation suggests:\n            # http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive\n            proxy_http_version 1.1;\n            proxy_set_header Connection \"\";\n            set $target {{ changeHostPort $externalAuth.URL $authUpstreamName }};\n            {{ else }}\n            proxy_http_version {{ $location.Proxy.ProxyHTTPVersion }};\n            set $target {{ $externalAuth.URL }};\n            {{ end }}\n            proxy_pass $target;\n        }\n        {{ end }}\n\n        {{ if isLocationAllowed $location }}\n        {{ if $externalAuth.SigninURL }}\n        location {{ buildAuthSignURLLocation $location.Path $externalAuth.SigninURL }} {\n            internal;\n\n            add_header Set-Cookie $auth_cookie;\n\n            {{ if $location.CorsConfig.CorsEnabled }}\n            {{ template \"CORS\" $location }}\n            {{ end }}\n\n            # Ensure that modsecurity will not run on an internal location as this is not accessible from outside\n            {{ if $all.Cfg.EnableModsecurity }}\n            modsecurity off;\n            {{ end }}\n\n            return 302 {{ buildAuthSignURL $externalAuth.SigninURL $externalAuth.SigninURLRedirectParam }};\n        }\n        {{ end }}\n        {{ end }}\n\n        location {{ $path }} {\n            {{ $ing := (getIngressInformation $location.Ingress $server.Hostname $location.IngressPath) }}\n            set $namespace      {{ $ing.Namespace | quote}};\n            set $ingress_name   {{ $ing.Rule | quote }};\n            set $service_name   {{ $ing.Service | quote }};\n            set $service_port   {{ $ing.ServicePort | quote }};\n            set $location_path  {{ $ing.Path | escapeLiteralDollar | quote }};\n            set $global_rate_limit_exceeding n;\n\n            {{ buildOpentracingForLocation $all.Cfg.EnableOpentracing $all.Cfg.OpentracingTrustIncomingSpan $location }}\n\n            {{ if $location.Mirror.Source }}\n            mirror {{ $location.Mirror.Source }};\n            mirror_request_body {{ $location.Mirror.RequestBody }};\n            {{ end }}\n\n            rewrite_by_lua_block {\n                lua_ingress.rewrite({{ locationConfigForLua $location $all }})\n                balancer.rewrite()\n                plugins.run()\n            }\n\n            # be careful with `access_by_lua_block` and `satisfy any` directives as satisfy any\n            # will always succeed when there's `access_by_lua_block` that does not have any lua code doing `ngx.exit(ngx.DECLINED)`\n            # other authentication method such as basic auth or external auth useless - all requests will be allowed.\n            #access_by_lua_block {\n            #}\n\n            header_filter_by_lua_block {\n                lua_ingress.header()\n                plugins.run()\n            }\n\n            body_filter_by_lua_block {\n                plugins.run()\n            }\n\n            log_by_lua_block {\n                balancer.log()\n                {{ if $all.EnableMetrics }}\n                monitor.call()\n                {{ end }}\n\n                plugins.run()\n            }\n\n            {{ if not $location.Logs.Access }}\n            access_log off;\n            {{ end }}\n\n            {{ if $location.Logs.Rewrite }}\n            rewrite_log on;\n            {{ end }}\n\n            {{ if $location.HTTP2PushPreload }}\n            http2_push_preload on;\n            {{ end }}\n\n            port_in_redirect {{ if $location.UsePortInRedirects }}on{{ else }}off{{ end }};\n\n            set $balancer_ewma_score -1;\n            set $proxy_upstream_name {{ buildUpstreamName $location | quote }};\n            set $proxy_host          $proxy_upstream_name;\n            set $pass_access_scheme  $scheme;\n\n            {{ if $all.Cfg.UseProxyProtocol }}\n            set $pass_server_port    $proxy_protocol_server_port;\n            {{ else }}\n            set $pass_server_port    $server_port;\n            {{ end }}\n\n            set $best_http_host      $http_host;\n            set $pass_port           $pass_server_port;\n\n            set $proxy_alternative_upstream_name \"\";\n\n            {{ buildModSecurityForLocation $all.Cfg $location }}\n\n            {{ if isLocationAllowed $location }}\n            {{ if gt (len $location.Denylist.CIDR) 0 }}\n            {{ range $ip := $location.Denylist.CIDR }}\n            deny {{ $ip }};{{ end }}\n            {{ end }}\n            {{ if gt (len $location.Whitelist.CIDR) 0 }}\n            {{ range $ip := $location.Whitelist.CIDR }}\n            allow {{ $ip }};{{ end }}\n            deny all;\n            {{ end }}\n\n            {{ if $location.CorsConfig.CorsEnabled }}\n            {{ template \"CORS\" $location }}\n            {{ end }}\n\n            {{ if not (isLocationInLocationList $location $all.Cfg.NoAuthLocations) }}\n            {{ if $authPath }}\n            # this location requires authentication\n            {{ if and (eq $applyAuthUpstream true) (eq $applyGlobalAuth false) }}\n            set $auth_cookie '';\n            add_header Set-Cookie $auth_cookie;\n            {{- range $line := buildAuthResponseHeaders $proxySetHeader $externalAuth.ResponseHeaders true }}\n            {{ $line }}\n            {{- end }}\n            # `auth_request` module does not support HTTP keepalives in upstream block:\n            # https://trac.nginx.org/nginx/ticket/1579\n            access_by_lua_block {\n                local res = ngx.location.capture('{{ $authPath }}', { method = ngx.HTTP_GET, body = '' })\n                if res.status == ngx.HTTP_OK then\n                    ngx.var.auth_cookie = res.header['Set-Cookie']\n                    {{- range $line := buildAuthUpstreamLuaHeaders $externalAuth.ResponseHeaders }}\n                    {{ $line }}\n                    {{- end }}\n                    return\n                end\n                if res.status == ngx.HTTP_UNAUTHORIZED or res.status == ngx.HTTP_FORBIDDEN then\n                    ngx.exit(res.status)\n                end\n                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n            }\n            {{ else }}\n            auth_request        {{ $authPath }};\n            auth_request_set    $auth_cookie $upstream_http_set_cookie;\n            {{ if $externalAuth.AlwaysSetCookie }}\n            add_header          Set-Cookie $auth_cookie always;\n            {{ else }}\n            add_header          Set-Cookie $auth_cookie;\n            {{ end }}\n            {{- range $line := buildAuthResponseHeaders $proxySetHeader $externalAuth.ResponseHeaders false }}\n            {{ $line }}\n            {{- end }}\n            {{ end }}\n            {{ end }}\n\n            {{ if $externalAuth.SigninURL }}\n            set_escape_uri $escaped_request_uri $request_uri;\n            error_page 401 = {{ buildAuthSignURLLocation $location.Path $externalAuth.SigninURL }};\n            {{ end }}\n\n            {{ if $location.BasicDigestAuth.Secured }}\n            {{ if eq $location.BasicDigestAuth.Type \"basic\" }}\n            auth_basic {{ $location.BasicDigestAuth.Realm | quote }};\n            auth_basic_user_file {{ $location.BasicDigestAuth.File }};\n            {{ else }}\n            auth_digest {{ $location.BasicDigestAuth.Realm | quote }};\n            auth_digest_user_file {{ $location.BasicDigestAuth.File }};\n            {{ end }}\n            {{ $proxySetHeader }} Authorization \"\";\n            {{ end }}\n            {{ end }}\n\n            {{/* if the location contains a rate limit annotation, create one */}}\n            {{ $limits := buildRateLimit $location }}\n            {{ range $limit := $limits }}\n            {{ $limit }}{{ end }}\n\n            {{ buildInfluxDB $location.InfluxDB }}\n\n            {{ if isValidByteSize $location.Proxy.BodySize true }}\n            client_max_body_size                    {{ $location.Proxy.BodySize }};\n            {{ end }}\n            {{ if isValidByteSize $location.ClientBodyBufferSize false }}\n            client_body_buffer_size                 {{ $location.ClientBodyBufferSize }};\n            {{ end }}\n\n            {{/* By default use vhost as Host to upstream, but allow overrides */}}\n            {{ if not (eq $proxySetHeader \"grpc_set_header\") }}\n            {{ if not (empty $location.UpstreamVhost) }}\n            {{ $proxySetHeader }} Host                   {{ $location.UpstreamVhost | quote }};\n            {{ else }}\n            {{ $proxySetHeader }} Host                   $best_http_host;\n            {{ end }}\n            {{ end }}\n\n            # Pass the extracted client certificate to the backend\n            {{ if not (empty $server.CertificateAuth.CAFileName) }}\n            {{ if $server.CertificateAuth.PassCertToUpstream }}\n            {{ $proxySetHeader }} ssl-client-cert        $ssl_client_escaped_cert;\n            {{ end }}\n            {{ $proxySetHeader }} ssl-client-verify      $ssl_client_verify;\n            {{ $proxySetHeader }} ssl-client-subject-dn  $ssl_client_s_dn;\n            {{ $proxySetHeader }} ssl-client-issuer-dn   $ssl_client_i_dn;\n            {{ end }}\n\n            # Allow websocket connections\n            {{ $proxySetHeader }}                        Upgrade           $http_upgrade;\n            {{ if $location.Connection.Enabled}}\n            {{ $proxySetHeader }}                        Connection        {{ $location.Connection.Header }};\n            {{ else }}\n            {{ $proxySetHeader }}                        Connection        $connection_upgrade;\n            {{ end }}\n\n            {{ $proxySetHeader }} X-Request-ID           $req_id;\n            {{ $proxySetHeader }} X-Real-IP              $remote_addr;\n            {{ if and $all.Cfg.UseForwardedHeaders $all.Cfg.ComputeFullForwardedFor }}\n            {{ $proxySetHeader }} X-Forwarded-For        $full_x_forwarded_for;\n            {{ else }}\n            {{ $proxySetHeader }} X-Forwarded-For        $remote_addr;\n            {{ end }}\n            {{ $proxySetHeader }} X-Forwarded-Host       $best_http_host;\n            {{ $proxySetHeader }} X-Forwarded-Port       $pass_port;\n            {{ $proxySetHeader }} X-Forwarded-Proto      $pass_access_scheme;\n            {{ $proxySetHeader }} X-Forwarded-Scheme     $pass_access_scheme;\n            {{ if $all.Cfg.ProxyAddOriginalURIHeader }}\n            {{ $proxySetHeader }} X-Original-URI         $request_uri;\n            {{ end }}\n            {{ $proxySetHeader }} X-Scheme               $pass_access_scheme;\n\n            # Pass the original X-Forwarded-For\n            {{ $proxySetHeader }} X-Original-Forwarded-For {{ buildForwardedFor $all.Cfg.ForwardedForHeader }};\n\n            # mitigate HTTPoxy Vulnerability\n            # https://www.nginx.com/blog/mitigating-the-httpoxy-vulnerability-with-nginx/\n            {{ $proxySetHeader }} Proxy                  \"\";\n\n            # Custom headers to proxied server\n            {{ range $k, $v := $all.ProxySetHeaders }}\n            {{ $proxySetHeader }} {{ $k }}                    {{ $v | quote }};\n            {{ end }}\n\n            proxy_connect_timeout                   {{ $location.Proxy.ConnectTimeout }}s;\n            proxy_send_timeout                      {{ $location.Proxy.SendTimeout }}s;\n            proxy_read_timeout                      {{ $location.Proxy.ReadTimeout }}s;\n\n            proxy_buffering                         {{ $location.Proxy.ProxyBuffering }};\n            proxy_buffer_size                       {{ $location.Proxy.BufferSize }};\n            proxy_buffers                           {{ $location.Proxy.BuffersNumber }} {{ $location.Proxy.BufferSize }};\n            {{ if isValidByteSize $location.Proxy.ProxyMaxTempFileSize true }}\n            proxy_max_temp_file_size                {{ $location.Proxy.ProxyMaxTempFileSize }};\n            {{ end }}\n            proxy_request_buffering                 {{ $location.Proxy.RequestBuffering }};\n            proxy_http_version                      {{ $location.Proxy.ProxyHTTPVersion }};\n\n            proxy_cookie_domain                     {{ $location.Proxy.CookieDomain }};\n            proxy_cookie_path                       {{ $location.Proxy.CookiePath }};\n\n            # In case of errors try the next upstream server before returning an error\n            proxy_next_upstream                     {{ buildNextUpstream $location.Proxy.NextUpstream $all.Cfg.RetryNonIdempotent }};\n            proxy_next_upstream_timeout             {{ $location.Proxy.NextUpstreamTimeout }};\n            proxy_next_upstream_tries               {{ $location.Proxy.NextUpstreamTries }};\n\n            {{/* Add any additional configuration defined */}}\n            {{ $location.ConfigurationSnippet }}\n\n            {{ if not (empty $all.Cfg.LocationSnippet) }}\n            # Custom code snippet configured in the configuration configmap\n            {{ $all.Cfg.LocationSnippet }}\n            {{ end }}\n\n            {{/* if we are sending the request to a custom default backend, we add the required headers */}}\n            {{ if (hasPrefix $location.Backend \"custom-default-backend-\") }}\n            proxy_set_header       X-Code             503;\n            proxy_set_header       X-Format           $http_accept;\n            proxy_set_header       X-Namespace        $namespace;\n            proxy_set_header       X-Ingress-Name     $ingress_name;\n            proxy_set_header       X-Service-Name     $service_name;\n            proxy_set_header       X-Service-Port     $service_port;\n            proxy_set_header       X-Request-ID       $req_id;\n            {{ end }}\n\n            {{ if $location.Satisfy }}\n            satisfy {{ $location.Satisfy }};\n            {{ end }}\n\n            {{/* if a location-specific error override is set, add the proxy_intercept here */}}\n            {{ if $location.CustomHTTPErrors }}\n            # Custom error pages per ingress\n            proxy_intercept_errors on;\n            {{ end }}\n\n            {{ range $errCode := $location.CustomHTTPErrors }}\n            error_page {{ $errCode }} = @custom_{{ $location.DefaultBackendUpstreamName }}_{{ $errCode }};{{ end }}\n\n            {{ if (eq $location.BackendProtocol \"FCGI\") }}\n            include /etc/nginx/fastcgi_params;\n            {{ end }}\n            {{- if $location.FastCGI.Index -}}\n            fastcgi_index {{ $location.FastCGI.Index | quote }};\n            {{- end -}}\n            {{ range $k, $v := $location.FastCGI.Params }}\n            fastcgi_param {{ $k }} {{ $v | quote }};\n            {{ end }}\n\n            {{ if not (empty $location.Redirect.URL) }}\n            return {{ $location.Redirect.Code }} {{ $location.Redirect.URL }};\n            {{ end }}\n\n            {{ buildProxyPass $server.Hostname $all.Backends $location }}\n            {{ if (or (eq $location.Proxy.ProxyRedirectFrom \"default\") (eq $location.Proxy.ProxyRedirectFrom \"off\")) }}\n            proxy_redirect                          {{ $location.Proxy.ProxyRedirectFrom }};\n            {{ else if not (eq $location.Proxy.ProxyRedirectTo \"off\") }}\n            proxy_redirect                          {{ $location.Proxy.ProxyRedirectFrom }} {{ $location.Proxy.ProxyRedirectTo }};\n            {{ end }}\n            {{ else }}\n            # Location denied. Reason: {{ $location.Denied | quote }}\n            return 503;\n            {{ end }}\n            {{ if not (empty $location.ProxySSL.CAFileName) }}\n            # PEM sha: {{ $location.ProxySSL.CASHA }}\n            proxy_ssl_trusted_certificate           {{ $location.ProxySSL.CAFileName }};\n            proxy_ssl_ciphers                       {{ $location.ProxySSL.Ciphers }};\n            proxy_ssl_protocols                     {{ $location.ProxySSL.Protocols }};\n            proxy_ssl_verify                        {{ $location.ProxySSL.Verify }};\n            proxy_ssl_verify_depth                  {{ $location.ProxySSL.VerifyDepth }};\n            {{ end }}\n\n            {{ if not (empty $location.ProxySSL.ProxySSLName) }}\n            proxy_ssl_name                          {{ $location.ProxySSL.ProxySSLName }};\n            {{ end }}\n            {{ if not (empty $location.ProxySSL.ProxySSLServerName) }}\n            proxy_ssl_server_name                   {{ $location.ProxySSL.ProxySSLServerName }};\n            {{ end }}\n\n            {{ if not (empty $location.ProxySSL.PemFileName) }}\n            proxy_ssl_certificate                   {{ $location.ProxySSL.PemFileName }};\n            proxy_ssl_certificate_key               {{ $location.ProxySSL.PemFileName }};\n            {{ end }}\n        }\n        {{ end }}\n        {{ end }}\n\n        {{ if eq $server.Hostname \"_\" }}\n        # health checks in cloud providers require the use of port {{ $all.ListenPorts.HTTP }}\n        location {{ $all.HealthzURI }} {\n            {{ if $all.Cfg.EnableOpentracing }}\n            opentracing off;\n            {{ end }}\n\n            access_log off;\n            return 200;\n        }\n\n        # this is required to avoid error if nginx is being monitored\n        # with an external software (like sysdig)\n        location /nginx_status {\n            {{ if $all.Cfg.EnableOpentracing }}\n            opentracing off;\n            {{ end }}\n\n            {{ range $v := $all.NginxStatusIpv4Whitelist }}\n            allow {{ $v }};\n            {{ end }}\n            {{ if $all.IsIPV6Enabled -}}\n            {{ range $v := $all.NginxStatusIpv6Whitelist }}\n            allow {{ $v }};\n            {{ end }}\n            {{ end -}}\n            deny all;\n\n            access_log off;\n            stub_status on;\n        }\n\n        {{ end }}\n\n{{ end }}\n"
